__version__ = "0.2.0"

def scan_debug_errors(root):
    import os, re

    pattern = re.compile(r"([\w./-]+)[: ]+(line )?(\d+)", re.I)
    results = []

    for name in os.listdir(root):
        if "error" in name.lower() and name.endswith((".log", ".txt")):
            path = os.path.join(root, name)
            try:
                for line in open(path, errors="ignore"):
                    m = pattern.search(line)
                    if m:
                        results.append({
                            "source": name,
                            "file": m.group(1),
                            "line": int(m.group(3)),
                            "raw": line.strip()
                        })
            except:
                pass

    return results

import os, sys, argparse, platform
from datetime import datetime

DEFAULT_EXT = {".txt",".md",".py",".php",".js",".html",".css",".json",".sql"}
DEFAULT_EXCLUDE = {".git","node_modules","vendor","__pycache__"}

def get_scan_workspace(repo):
    base = os.path.join(get_download_dir(), "Scan")
    path = os.path.join(base, repo)
    os.makedirs(path, exist_ok=True)
    return path

def get_download_dir():

    # Detect Termux explicitly
    if os.path.exists("/data/data/com.termux"):
        return os.path.expanduser("~/storage/downloads")

    system = platform.system().lower()

    if system == "linux":
        return os.path.expanduser("~/Downloads")

    if system == "windows":
        return os.path.join(os.environ.get("USERPROFILE", ""), "Downloads")

    return os.getcwd()

def build_tree(root, exclude):
    lines = []
    dir_count = file_count = 0

    def walk(path, prefix=""):
        nonlocal dir_count, file_count
        try:
            items = sorted(os.listdir(path))
        except PermissionError:
            return

        for i, name in enumerate(items):
            if name in exclude:
                continue
            full = os.path.join(path, name)
            connector = "└── " if i == len(items)-1 else "├── "
            if os.path.isdir(full) and not os.path.islink(full):
                dir_count += 1
                lines.append(prefix + connector + name)
                walk(full, prefix + ("    " if i == len(items)-1 else "│   "))
            else:
                file_count += 1
                if os.path.islink(full):
                    lines.append(prefix + connector + f"{name} -> {os.readlink(full)}")
                else:
                    lines.append(prefix + connector + name)

    lines.append(".")
    walk(root)
    lines.append(f"\n{dir_count} directories, {file_count} files")
    return "\n".join(lines)

def scan_files(root, exts, exclude):
    for r, d, f in os.walk(root):
        d[:] = [x for x in d if x not in exclude]
        for file in f:
            if file.startswith("dirscan_"):
                continue
            ext = os.path.splitext(file)[1].lower()
            if ext in exts:
                yield os.path.join(r, file)

def main():
    p = argparse.ArgumentParser(
        "tsc",
        description="repository artifact generator"
    )
    p.add_argument("path", nargs="?", default=".")
    p.add_argument("-i", metavar="ID", help="add identifier to output name")
    p.add_argument("-s", action="store_true", help="show repository summary")
    p.add_argument("-r", action="store_true", help="raw scan (disable ignore)")
    p.add_argument("-d", action="store_true", help="doctor mode (diagnose repo)")

    args = p.parse_args()

    # =========================
    # DEBUG MODE (exclusive)
    # =========================

if __name__ == "__main__":
    main()